| package |
package := Package name: 'SSW ReStore Collections'.
package paxVersion: 1;
	basicComment: 'ReStore
©2019 John Aspinall
https://github.com/rko281/ReStore'.


package classNames
	add: #SSWDBCollectionAddition;
	add: #SSWDBCollectionChange;
	add: #SSWDBCollectionEntry;
	add: #SSWDBCollectionIndexUpdate;
	add: #SSWDBCollectionObjectRemoval;
	add: #SSWDBCollectionRemoval;
	add: #SSWDBCollectionSpec;
	add: #SSWDBCollectionUpdate;
	add: #SSWDBDictionaryEntry;
	add: #SSWDBGeneralCollectionSpec;
	add: #SSWDBKeyedCollectionEntry;
	add: #SSWDBKeyedStaticCollectionSpec;
	add: #SSWDBOrderedStaticCollectionSpec;
	add: #SSWDBOwnedCollectionSpec;
	add: #SSWDBSortedStaticCollectionSpec;
	add: #SSWDBStaticCacheDictionarySpec;
	add: #SSWDBStaticCollectionSpec;
	add: #SSWDBStaticDictionarySpec;
	yourself.

package methodNames
	add: #ArrayedCollection -> #_changesFrom:;
	add: #ArrayedCollection -> #directAdd:suggestedIndex:;
	add: #Class -> #beKeyClassOf:;
	add: #Class -> #beTargetClassOf:;
	add: #Collection -> #_changesFrom:;
	add: #Collection -> #_collectionAdditions;
	add: #Collection -> #_dbAdd:;
	add: #Collection -> #_fetchComponents:;
	add: #Collection -> #_keyedChangesFrom:;
	add: #Collection -> #_keyedCollectionAdditions;
	add: #Collection -> #_keyRemovalsIn:;
	add: #Collection -> #_nonKeyedCollectionAdditions;
	add: #Collection -> #_valueRemovalsIn:;
	add: #Collection -> #_valuesRemovedBy:;
	add: #Collection -> #directAdd:;
	add: #Collection -> #directAdd:suggestedIndex:;
	add: #Collection -> #fetchComponent:;
	add: #Collection -> #fetchComponents:;
	add: #Collection -> #isOrdered;
	add: #Collection -> #isSortedCollection;
	add: #Collection -> #isValidForPersistence;
	add: #Collection -> #of:;
	add: #Collection -> #of:owner:;
	add: #Collection -> #of:specClass:;
	add: #Collection -> #orRemote;
	add: #Collection -> #ownedCollectionSpecClass;
	add: #Collection -> #remote;
	add: #Collection -> #staticCollectionSpecClass;
	add: #Dictionary -> #_changesFrom:;
	add: #Dictionary -> #_collectionAdditions;
	add: #Dictionary -> #_keyRemovalsIn:;
	add: #Dictionary -> #_valuesRemovedBy:;
	add: #Dictionary -> #directAdd:suggestedIndex:;
	add: #Dictionary -> #directAt:put:;
	add: #Dictionary -> #of:keyClass:;
	add: #Dictionary -> #of:keyedOn:;
	add: #Dictionary -> #staticCollectionSpecClass;
	add: #OrderedCollection -> #_changesFrom:;
	add: #SequenceableCollection -> #_collectionAdditions;
	add: #SequenceableCollection -> #isOrdered;
	add: #SequenceableCollection -> #staticCollectionSpecClass;
	add: #Set -> #_changesFrom:;
	add: #Set -> #_superValuesRemovedBy:;
	add: #Set -> #_valuesRemovedBy:;
	add: #SortedCollection -> #_changesFrom:;
	add: #SortedCollection -> #_collectionAdditions;
	add: #SortedCollection -> #_dbAdd:;
	add: #SortedCollection -> #directAdd:;
	add: #SortedCollection -> #isSortedCollection;
	add: #SortedCollection -> #orderingSpecsFor:in:;
	add: #SortedCollection -> #staticCollectionSpecClass;
	add: #SSWDBDependentWrapper -> #beKeyClassOf:;
	add: #SSWDBDependentWrapper -> #beTargetClassOf:;
	add: #SSWDBRelatedWrapper -> #beKeyClassOf:;
	add: #SSWDBRelatedWrapper -> #beTargetClassOf:;
	add: #SSWDBUnrelatedWrapper -> #beKeyClassOf:;
	add: #SSWDBUnrelatedWrapper -> #beTargetClassOf:;
	add: 'Collection class' -> #of:;
	add: 'Collection class' -> #of:owner:;
	add: 'Dictionary class' -> #of:keyClass:;
	add: 'Dictionary class' -> #of:keyedOn:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'SSW ReStore Base Additions'
	'SSW ReStore SQL Entities'
	'SSW ReStore SQL Queries'
	'SSW ReStore Tables').

package!

"Class Definitions"!

Object subclass: #SSWDBCollectionChange
	instanceVariableNames: 'affectedEntry'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #SSWDBCollectionEntry
	instanceVariableNames: 'table entryID sourceID target'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #SSWDBCollectionObjectRemoval
	instanceVariableNames: 'removedObject'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionChange subclass: #SSWDBCollectionAddition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionChange subclass: #SSWDBCollectionIndexUpdate
	instanceVariableNames: 'newIndex'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionChange subclass: #SSWDBCollectionRemoval
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionChange subclass: #SSWDBCollectionUpdate
	instanceVariableNames: 'newTarget'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionEntry subclass: #SSWDBDictionaryEntry
	instanceVariableNames: 'keyAccessor'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionEntry subclass: #SSWDBKeyedCollectionEntry
	instanceVariableNames: 'index'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBTableComponent subclass: #SSWDBCollectionSpec
	instanceVariableNames: 'templateCollection isValueDependent isValueRelated readStatement refreshStatement refreshWithContentsIfUpdatedStatement'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionSpec subclass: #SSWDBGeneralCollectionSpec
	instanceVariableNames: 'sourceField targetField collectionTable'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBCollectionSpec subclass: #SSWDBOwnedCollectionSpec
	instanceVariableNames: 'targetClass ownerField ownerAccessor orderingSpecs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBGeneralCollectionSpec subclass: #SSWDBStaticCollectionSpec
	instanceVariableNames: 'targetClass'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBStaticCollectionSpec subclass: #SSWDBKeyedStaticCollectionSpec
	instanceVariableNames: 'indexField updateIndexStatement'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBStaticCollectionSpec subclass: #SSWDBSortedStaticCollectionSpec
	instanceVariableNames: 'orderingSpecs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBStaticCollectionSpec subclass: #SSWDBStaticCacheDictionarySpec
	instanceVariableNames: 'keyAccessor'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBKeyedStaticCollectionSpec subclass: #SSWDBOrderedStaticCollectionSpec
	instanceVariableNames: 'updateTargetStatement'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWDBKeyedStaticCollectionSpec subclass: #SSWDBStaticDictionarySpec
	instanceVariableNames: 'keyClass isKeyDependent isKeyRelated'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!ArrayedCollection methodsFor!

_changesFrom: aCollectionOfEntries

	"Return the changes made to the receiver compared to aCollectionOf(Collection)Entries.
	For an array, there are no additions or removals - just updates"

	| entriesSize changes |

	entriesSize := aCollectionOfEntries size. 
	changes := OrderedCollection new: (self size // 10).

	self keysAndValuesDo:
		[ :index :each |
		index > entriesSize
		ifTrue:
			[each isNil ifFalse: 
				[changes add: (SSWDBCollectionAddition added: each at: index)]]
		ifFalse:
			[| entry |
			entry := aCollectionOfEntries at: index.
			entry target == each ifFalse: 
				[changes add: (SSWDBCollectionUpdate entry: entry newTarget: each)]]].

	^changes!

directAdd: anObject suggestedIndex: anInteger

	"Translate to at:put:"

	^self at: anInteger put: anObject

! !
!ArrayedCollection categoriesFor: #_changesFrom:!comparing!private! !
!ArrayedCollection categoriesFor: #directAdd:suggestedIndex:!adding!private! !

!Class methodsFor!

beKeyClassOf: aCollectionSpec

	"The receiver has been specified as the class of objects which are the keys 
	of the collection specified by aCollectionSpec.
	Initialize aCollectionSpec accordingly"

	aCollectionSpec keyClass: self!

beTargetClassOf: aCollectionSpec

	"The receiver has been specified as the class of objects held in 
	the collection specified by aCollectionSpec.
	Initialize aCollectionSpec accordingly"

	aCollectionSpec targetClass: self! !
!Class categoriesFor: #beKeyClassOf:!accessing!public! !
!Class categoriesFor: #beTargetClassOf:!accessing!public! !

!Collection methodsFor!

_changesFrom: aCollectionOfEntries

	"Return the changes made to the receiver compared to aCollectionOf(SSWDBCollection)Entries,
	as a collection of SSWDBCollectionChanges"

	^self subclassResponsibility!

_collectionAdditions

	"Return an collection of SSWDBCollectionAdditions representing the addition of 
	all the receiver's elements to an empty collection.
	Default - defer to _nonKeyedCollectionAdditions (assume receiver does not support keys). 
	Collections with keys/indexes should reimplement to include key/index information"

	^self _nonKeyedCollectionAdditions!

_dbAdd: anObject

	"For use when instantiating a collection from the database.
	Normally the same as add: but see SortedCollection implementation"

	^self add: anObject!

_fetchComponents: aCollection

	"Private - ReStore - for each element of the receiver, use a single query (ideally, or multiple batched queries if the receiver's size is too large for the readAll batch size)
	to fetch from the database the components in the inst vars named in aCollection"

	| any reStore table |

	self isEmpty ifTrue: [^self].
	any := self anyOne. 
	reStore := any _reStore.
	table := reStore tableForClass: any class.

	aCollection do: [ :instVar | (table componentAccessing: instVar) readAllFor: self]

	!

_keyedChangesFrom: aCollectionOfEntries

	"Return the changes made to the receiver compared to aCollectionOf(Collection)Entries.
	For keyed changes, must consider additions, removals and changes of key"

	| changes map |

	changes := OrderedCollection new: (self size // 10).
	map := IdentityDictionary new: aCollectionOfEntries size.

	"Make a map of each element (as was) to its entry(s)"
	aCollectionOfEntries do: 
		[ :each | (map at: each target ifAbsentPut: [OrderedCollection new: 1]) addLast: each].

	"Locate and remove entry for each member of the receiver and check for key change"
	self keysAndValuesDo:
		[ :newKey :each || entry |
		entry := (map at: each ifAbsent: [##(OrderedCollection new)]) removeFirstIfAbsent:
			"No entry found = element has been added to the receiver" 
			[(changes add: (SSWDBCollectionAddition added: each at: newKey)) affectedEntry].
		entry index = newKey ifFalse: 
			[changes add: (SSWDBCollectionIndexUpdate entry: entry newIndex: newKey)]].

	"Any remaining entries indicate elements removed from the receiver"
	map keysAndValuesDo:
		[ :each :entries | 
		entries isEmpty ifFalse:		"Minor optimisation"
			[entries do: [ :entry | changes add: (SSWDBCollectionRemoval newWithEntry: entry)]]].

	^changes!

_keyedCollectionAdditions

	"Return a collection of SSWDBCollectionAdditions representing the addition of 
	all the receiver's elements to an empty collection. 
	Include the key of each element (as used by keysAndValuesDo:)"

	| additions |

	additions := OrderedCollection new.

	self keysAndValuesDo: [ :key :each | additions add: (SSWDBCollectionAddition added: each at: key)].

	^additions!

_keyRemovalsIn: aCollectionOfChanges

	"Return a collection of SSWDBCollectionObjectRemovals representing those keys (indexes)
	removed from the receiver by aCollectionOfChanges.

	Default - none. Subclasses for whom this is important (i.e. have persistent indexes) should implement"

	^#()!

_nonKeyedCollectionAdditions

	"Return an collection of SSWDBCollectionAdditions representing the addition of 
	all the receiver's elements to an empty collection.
	The SSWDBCollectionAdditions do not contain key information"

	| additions |

	additions := OrderedCollection new.

	self do: [ :each | additions add: (SSWDBCollectionAddition added: each)].

	^additions!

_valueRemovalsIn: aCollectionOfChanges

	"Return a collection of SSWDBCollectionObjectRemovals representing those values (objects)
	removed from the receiver which are the targets of the affectedEntries of aCollectionOfChanges"

	| removalChanges |

	"Restrict the changes to just those that can potentially result in the removal of a value object"
	removalChanges := aCollectionOfChanges select: [ :change | change canRemoveValue].

	^(self _valuesRemovedBy: removalChanges) collect: 
		[ :valueObject | SSWDBCollectionObjectRemoval newWithObject: valueObject]!

_valuesRemovedBy: aCollectionOfChanges

	"Return those values (objects) completely removed from the receiver by aCollectionOfChanges"

	| affectedObjects |

	affectedObjects := aCollectionOfChanges collect: [ :change | change affectedEntry target].

	^affectedObjects asIdentitySet reject: [ :object | self identityIncludes: object]!

directAdd: anObject

	"Add anObject to the receiver.
	Sent by ReStore when populating a collection; assume elements are added in correct order
	and so bypass any internal ordering (e.g. see SortedCollection>>directAdd:)"

	^self add: anObject!

directAdd: anObject suggestedIndex: anInteger

	"Add anObject to the receiver, possibly at the index anInteger.
	The suggestedIndex is only required by keyed collections, 
	so defer to just directAdd:"

	^self directAdd: anObject!

fetchComponent: aSymbol

	"ReStore - for each element of the receiver, use a single query (ideally, or multiple batched queries if the receiver's size is too large for the readAll batch size)
	to fetch from the database the component in the inst var named aSymbol"

	^self fetchComponents: (Array with: aSymbol)!

fetchComponents: aCollection

	"ReStore - for each element of the receiver, use a single query (ideally, or multiple batched queries if the receiver's size is too large for the readAll batch size)
	to fetch from the database the components in the inst vars named in aCollection"

	^(self select: [ :each | each _isRecovered]) _fetchComponents: aCollection!

isOrdered

	^false
!

isSortedCollection

	^false
!

isValidForPersistence

	"Collections are not persisted directly (e.g. via storeIn:), therefore consider them already persistent"

	^true!

of: targetClass

	"ReStore specification method - specifies a general (M to M) collection containing aClass.
	Create and return an appropriate SSWDBCollectionSpec"

	^self of: targetClass specClass: self staticCollectionSpecClass!

of: targetClass owner: aSymbol

	"ReStore specification method - specifies a 1 to many collection, containing aClass,
	whose inst var named aSymbol holds the owning (1) object.

	Create and return an appropriate SSWDBCollectionSpec"

	^self ownedCollectionSpecClass new
		templateCollection: self;
		setTargetClass: targetClass;
		owner: aSymbol;
		yourself
!

of: targetClass specClass: specClass

	"ReStore specification method - specifies a general (M to M) collection containing aClass.
	Create, initialize and return a configured instance of the given SSWDBCollectionSpec class"

	^specClass new
		templateCollection: self;
		setTargetClass: targetClass;
		yourself!

orRemote

	"The receiver is already in memory, return it"

	^self!

ownedCollectionSpecClass 

	"Return the class of owned collection spec that is appropriate for this kind of collection"

	^SSWDBOwnedCollectionSpec

!

remote

	"Defer to the proxy"

	^self _dbProxy remote!

staticCollectionSpecClass 

	"Return the class of static collection spec that is appropriate for this kind of collection.
	Subclasses for which this may differ depending on mode of use should not implement this,
	but should route configuration through of:specClass: "

	^SSWDBStaticCollectionSpec

! !
!Collection categoriesFor: #_changesFrom:!private!restore-internal! !
!Collection categoriesFor: #_collectionAdditions!private!restore-internal! !
!Collection categoriesFor: #_dbAdd:!private!restore-internal! !
!Collection categoriesFor: #_fetchComponents:!private!restore-internal! !
!Collection categoriesFor: #_keyedChangesFrom:!private!restore-internal! !
!Collection categoriesFor: #_keyedCollectionAdditions!private!restore-internal! !
!Collection categoriesFor: #_keyRemovalsIn:!private!restore-internal! !
!Collection categoriesFor: #_nonKeyedCollectionAdditions!private!restore-internal! !
!Collection categoriesFor: #_valueRemovalsIn:!private!restore-internal! !
!Collection categoriesFor: #_valuesRemovedBy:!private!restore-internal! !
!Collection categoriesFor: #directAdd:!adding!private! !
!Collection categoriesFor: #directAdd:suggestedIndex:!adding!private! !
!Collection categoriesFor: #fetchComponent:!converting!public! !
!Collection categoriesFor: #fetchComponents:!converting!public! !
!Collection categoriesFor: #isOrdered!public!testing! !
!Collection categoriesFor: #isSortedCollection!public!testing! !
!Collection categoriesFor: #isValidForPersistence!comparing!private! !
!Collection categoriesFor: #of:!public!specification! !
!Collection categoriesFor: #of:owner:!public!specification! !
!Collection categoriesFor: #of:specClass:!public!specification! !
!Collection categoriesFor: #orRemote!converting!public! !
!Collection categoriesFor: #ownedCollectionSpecClass!constants!private! !
!Collection categoriesFor: #remote!converting!public! !
!Collection categoriesFor: #staticCollectionSpecClass!constants!private! !

!Collection class methodsFor!

of: targetClass

	^self new of: targetClass
!

of: targetClass owner: aSymbol

	^self new of: targetClass owner: aSymbol

! !
!Collection class categoriesFor: #of:!public!specification! !
!Collection class categoriesFor: #of:owner:!public!specification! !

!Dictionary methodsFor!

_changesFrom: aCollectionOfEntries

	"Override to include key information if necessary. 
	This can be determined from any member of aCollectionOfEntries.
	Defer to _collectionAdditions if empty (to give keyed entries, issue#0026) "

	^aCollectionOfEntries isEmpty 
	ifTrue:
		[self _collectionAdditions]
	ifFalse:
		[(aCollectionOfEntries first isKindOf: SSWDBDictionaryEntry)
			ifTrue: [super _changesFrom: aCollectionOfEntries]
			ifFalse: [self _keyedChangesFrom: aCollectionOfEntries]]!

_collectionAdditions

	"Override to include key information"

	^self _keyedCollectionAdditions!

_keyRemovalsIn: aCollectionOfChanges

	^(aCollectionOfChanges isEmpty or: [aCollectionOfChanges first affectedEntry isKindOf: SSWDBDictionaryEntry])
	ifTrue:
		[#()]
	ifFalse:
		[aCollectionOfChanges
			select: [ :change | change canRemoveKey and: [(self includesKey: change affectedEntry index) not]]
			thenCollect: [ :change | SSWDBCollectionObjectRemoval newWithObject: change affectedEntry index]]!

_valuesRemovedBy: aCollectionOfChanges

	"The receiver is not a set (i.e. allows duplicates) and so cannot take advantage of superclass optimisation"

	^self _superValuesRemovedBy: aCollectionOfChanges!

directAdd: targetObject suggestedIndex: keyObject

	"Make the receiver polymorphic with an indexed collection (key=index)"

	^self directAt: keyObject put: targetObject
!

directAt: aKey put: anObject

	^self at: aKey put: anObject!

of: targetClass keyClass: keyClass

	"ReStore specification method - specify a Dictionary which stores instances of targetClass.
	The Dictionary's keys will be of the class keyClass, which should be a valid persistent class.
	Create and return an appropriate SSWDBCollectionSpec"

	^(self of: targetClass specClass: SSWDBStaticDictionarySpec)
		setKeyClass: keyClass;
		yourself!

of: targetClass keyedOn: aSymbol

	"ReStore specification method - specify a Dictionary which stores instances of targetClass.
	Instances are stored in the receiver at: the value of their instance variable named aSymbol.
	Create and return an appropriate SSWDBCollectionSpec"

	^(self of: targetClass specClass: SSWDBStaticCacheDictionarySpec)
		keyedOn: aSymbol;
		yourself!

staticCollectionSpecClass 

	"Do not implement this method, the staticCollectionSpecClass for Dictionaries varies
	(see of:xxxx: variants)"

	^self shouldNotImplement

! !
!Dictionary categoriesFor: #_changesFrom:!comparing!public! !
!Dictionary categoriesFor: #_collectionAdditions!comparing!public! !
!Dictionary categoriesFor: #_keyRemovalsIn:!comparing!private! !
!Dictionary categoriesFor: #_valuesRemovedBy:!comparing!private! !
!Dictionary categoriesFor: #directAdd:suggestedIndex:!comparing!public! !
!Dictionary categoriesFor: #directAt:put:!adding!private! !
!Dictionary categoriesFor: #of:keyClass:!public!specification! !
!Dictionary categoriesFor: #of:keyedOn:!public!specification! !
!Dictionary categoriesFor: #staticCollectionSpecClass!constants!private! !

!Dictionary class methodsFor!

of: targetClass keyClass: keyClass

	"ReStore specification method - create and return an appropriate SSWDBCollectionSpec"

	^self new of: targetClass keyClass: keyClass!

of: targetClass keyedOn: aSymbol

	"ReStore specification method - create and return an appropriate SSWDBCollectionSpec"

	^self new of: targetClass keyedOn: aSymbol! !
!Dictionary class categoriesFor: #of:keyClass:!public!specification! !
!Dictionary class categoriesFor: #of:keyedOn:!public!specification! !

!OrderedCollection methodsFor!

_changesFrom: aCollectionOfEntries

	"Return the changes made to the receiver compared to aCollectionOf(Collection)Entries.
	For an OrderedCollection, must include full keyed (indexed) changes"

	^self _keyedChangesFrom: aCollectionOfEntries! !
!OrderedCollection categoriesFor: #_changesFrom:!comparing!private! !

!SequenceableCollection methodsFor!

_collectionAdditions

	"Reimplemented to include index (key) information"

	^self _keyedCollectionAdditions!

isOrdered

	^true
!

staticCollectionSpecClass 

	^SSWDBOrderedStaticCollectionSpec

! !
!SequenceableCollection categoriesFor: #_collectionAdditions!comparing!private! !
!SequenceableCollection categoriesFor: #isOrdered!public!testing! !
!SequenceableCollection categoriesFor: #staticCollectionSpecClass!constants!private! !

!Set methodsFor!

_changesFrom: aSetOfEntries

	"Return the changes made to the receiver compared to aSetOf(Collection)Entries.
	For a Set, consider additions and removals and removal only"

	| changes oldSet |

	changes := OrderedCollection new.
	oldSet := aSetOfEntries collect: [ :entry | entry target].

	self do: [ :each | (oldSet identityIncludes: each) ifFalse: 
						[changes add: (SSWDBCollectionAddition added: each)]].

	aSetOfEntries do: [ :entry | (self identityIncludes: entry target) ifFalse: 
						[changes add: (SSWDBCollectionRemoval newWithEntry: entry)]].

	^changes!

_superValuesRemovedBy: aCollectionOfChanges

	"Pass-thru to default implementation of _valuesRemovedBy: for benefit of non-Set subclasses"

	^super _valuesRemovedBy: aCollectionOfChanges
!

_valuesRemovedBy: aCollectionOfChanges

	"Overriden to take advantage of the lack of duplicates in the receiver:
	if a change removes an element from the receiver, then all occurrences of that element are removed"

	^aCollectionOfChanges collect: [ :each | each affectedEntry target]! !
!Set categoriesFor: #_changesFrom:!comparing!private! !
!Set categoriesFor: #_superValuesRemovedBy:!comparing!private! !
!Set categoriesFor: #_valuesRemovedBy:!comparing!private! !

!SortedCollection methodsFor!

_changesFrom: aCollectionOfEntries

	"Return the changes made to the receiver compared to aCollectionOf(Collection)Entries.
	For a SortedCollection, can ignore index changes"

	| changes map |

	changes := OrderedCollection new: (self size // 10).
	map := IdentityDictionary new: aCollectionOfEntries size.

	"Make a map of each element (as was) to its entry(s)"
	aCollectionOfEntries do: 
		[ :each | (map at: each target ifAbsentPut: [OrderedCollection new: 1]) addLast: each].

	"Locate and remove entry for each member of the receiver"
	self keysAndValuesDo:
		[ :newIndex :each |
		(map at: each ifAbsent: [##(OrderedCollection new)]) removeFirstIfAbsent:
			"No entry found = element has been added to the receiver" 
			[changes add: (SSWDBCollectionAddition added: each)]].

	"Any remaining entries indicate elements removed from the receiver"
	map keysAndValuesDo:
		[ :each :entries | 
		entries isEmpty ifFalse:		"Minor optimisation"
			[entries do: [ :entry | changes add: (SSWDBCollectionRemoval newWithEntry: entry)]]].

	^changes!

_collectionAdditions

	"Defer to _nonKeyedCollectionAdditions, since indexing does not need to be stored 
	(it is defined by the sorting criteria)"

	^self _nonKeyedCollectionAdditions!

_dbAdd: anObject

	"For use when instantiating a collection from the database.
	Sorting is done by the recovery query, so we need to use an unconditional addLast: to avoice the expense of sorting, and potentially interrogating a non-recovered persistent object"

	^super addLast: anObject!

directAdd: anObject

	"For speed, ReStore will instruct the database to recover objects already sorted.
	directAdd: allows these sorted objects to be added to the receiver without further sorting"

	^super addLast: anObject!

isSortedCollection

	^true
!

orderingSpecsFor: aClass in: aReStore

	"Convert the receiver's sortBlock into DBOrderingSpecs"

	^(self sortBlock = SortedCollection new sortBlock and: [aClass isPersistentBaseClass]) "default ascending sort"
	ifTrue:
		[OrderedCollection with: (SSWDBOrderingSpec ascending: #target)]
	ifFalse:
		[| instances |
		instances := aReStore instancesOf: aClass.
		instances sortBlock: (self sortBlock ifNil: [SortedCollection defaultSortBlock]).
		instances parser orderingSpecs collect: 
			[ :each || field |
			field := each criteria.
			field isNil 
				ifTrue: [each criteria: #target]
				ifFalse: [each criteria: field accessor name]]]!

staticCollectionSpecClass 

	^SSWDBSortedStaticCollectionSpec

! !
!SortedCollection categoriesFor: #_changesFrom:!comparing!private! !
!SortedCollection categoriesFor: #_collectionAdditions!comparing!private! !
!SortedCollection categoriesFor: #_dbAdd:!comparing!private! !
!SortedCollection categoriesFor: #directAdd:!adding!public! !
!SortedCollection categoriesFor: #isSortedCollection!public!testing! !
!SortedCollection categoriesFor: #orderingSpecsFor:in:!accessing!private! !
!SortedCollection categoriesFor: #staticCollectionSpecClass!constants!private! !

!SSWDBDependentWrapper methodsFor!

beKeyClassOf: aTableComponent

	"Polymorphic with the Class implementation"
		
	super beKeyClassOf: aTableComponent.
	aTableComponent beKeyDependent!

beTargetClassOf: aTableComponent

	"Polymorphic with the Class implementation"

	super beTargetClassOf: aTableComponent.
	aTableComponent beValueDependent! !
!SSWDBDependentWrapper categoriesFor: #beKeyClassOf:!defining!public! !
!SSWDBDependentWrapper categoriesFor: #beTargetClassOf:!defining!public! !

!SSWDBRelatedWrapper methodsFor!

beKeyClassOf: aTableComponent

	"Polymorphic with the Class implementation"

	self relatedObject beKeyClassOf: aTableComponent.
	aTableComponent beKeyRelated!

beTargetClassOf: aTableComponent

	"Polymorphic with the Class implementation"

	self relatedObject beTargetClassOf: aTableComponent.
	aTableComponent beValueRelated! !
!SSWDBRelatedWrapper categoriesFor: #beKeyClassOf:!defining!public! !
!SSWDBRelatedWrapper categoriesFor: #beTargetClassOf:!defining!public! !

!SSWDBUnrelatedWrapper methodsFor!

beKeyClassOf: aTableComponent

	"Polymorphic with the Class implementation"

	self unrelatedObject beKeyClassOf: aTableComponent.
	aTableComponent beKeyUnrelated!

beTargetClassOf: aTableComponent

	"Polymorphic with the Class implementation"

	self unrelatedObject beTargetClassOf: aTableComponent.
	aTableComponent beValueUnrelated! !
!SSWDBUnrelatedWrapper categoriesFor: #beKeyClassOf:!defining!public! !
!SSWDBUnrelatedWrapper categoriesFor: #beTargetClassOf:!defining!public! !

"End of package definition"!

